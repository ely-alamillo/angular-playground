"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ts = require("typescript");
var Lint = require("tslint");
var Ignore = require("./shared/ignore");
var check_node_1 = require("./shared/check-node");
/**
 * This rule checks that the readonly keyword is used in all PropertySignature and
 * IndexerSignature nodes (which are the only places that the readonly keyword can exist).
 */
// tslint:disable-next-line:variable-name
exports.Rule = check_node_1.createCheckNodeRule(Ignore.checkNodeWithIgnore(checkNode), "A readonly modifier is required.");
function checkNode(node, ctx) {
    return { invalidNodes: checkPropertySignatureAndIndexSignature(node, ctx) };
}
function checkPropertySignatureAndIndexSignature(node, ctx) {
    if (node.kind === ts.SyntaxKind.PropertySignature ||
        node.kind === ts.SyntaxKind.IndexSignature ||
        node.kind === ts.SyntaxKind.PropertyDeclaration) {
        if (!(node.modifiers &&
            node.modifiers.filter(function (m) { return m.kind === ts.SyntaxKind.ReadonlyKeyword; })
                .length > 0)) {
            // Check if ignore-prefix applies
            if (Ignore.shouldIgnorePrefix(node, ctx.options, ctx.sourceFile)) {
                return [];
            }
            var length_1 = node.getWidth(ctx.sourceFile);
            // const fulltext = node.getText(ctx.sourceFile);
            var fulltext = node.getText(ctx.sourceFile);
            return [
                check_node_1.createInvalidNode(node, new Lint.Replacement(node.end - length_1, length_1, "readonly " + fulltext))
            ];
        }
    }
    return [];
}
//# sourceMappingURL=readonlyKeywordRule.js.map