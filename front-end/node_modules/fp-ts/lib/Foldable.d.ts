import { HKT, HKTS, HKT2S, HKTAs, HKT2As, HKT3S, HKT3As } from './HKT';
import { Monoid } from './Monoid';
import { Applicative } from './Applicative';
import { Predicate } from './function';
import { Ord } from './Ord';
import { Option } from './Option';
import { Semiring } from './Semiring';
import { Monad } from './Monad';
import { Plus } from './Plus';
import { Setoid } from './Setoid';
/** @typeclass */
export interface Foldable<F> {
    readonly URI: F;
    reduce<A, B>(f: (b: B, a: A) => B, b: B, fa: HKT<F, A>): B;
}
export interface FantasyFoldable<A> {
    reduce<B>(f: (b: B, a: A) => B, b: B): B;
}
export interface FoldableComposition<F, G> {
    reduce<A, B>(f: (b: B, a: A) => B, b: B, fga: HKT<F, HKT<G, A>>): B;
}
/** @function */
export declare const getFoldableComposition: <F, G>(F: Foldable<F>, G: Foldable<G>) => FoldableComposition<F, G>;
/**
 * A default implementation of `foldMap` using `foldl`
 * @function
 */
export declare const foldMap: <F, M>(F: Foldable<F>, M: Monoid<M>) => <A>(f: (a: A) => M) => (fa: HKT<F, A>) => M;
/**
 * A default implementation of `foldr` using `foldMap`
 * @function
 */
export declare const foldr: <F>(F: Foldable<F>) => <A, B>(f: (a: A) => (b: B) => B) => (b: B) => (fa: HKT<F, A>) => B;
/** @function */
export declare const fold: <F, M>(F: Foldable<F>, M: Monoid<M>) => (fa: HKT<F, M>) => M;
/**
 * Similar to 'reduce', but the result is encapsulated in a monad.
 *
 * Note: this function is not generally stack-safe, e.g., for monads which
 * build up thunks a la `IO`.
 */
export declare function foldM<F, M extends HKT3S>(F: Foldable<F>, M: Monad<M>): <U, L, A, B>(f: (b: B, a: A) => HKT3As<M, U, L, B>, b: B, fa: HKT<F, A>) => HKT3As<M, U, L, B>;
export declare function foldM<F, M extends HKT2S>(F: Foldable<F>, M: Monad<M>): <L, A, B>(f: (b: B, a: A) => HKT2As<M, L, B>, b: B, fa: HKT<F, A>) => HKT2As<M, L, B>;
export declare function foldM<F, M extends HKTS>(F: Foldable<F>, M: Monad<M>): <A, B>(f: (b: B, a: A) => HKTAs<M, B>, b: B, fa: HKT<F, A>) => HKTAs<M, B>;
export declare function foldM<F, M>(F: Foldable<F>, M: Monad<M>): <A, B>(f: (b: B, a: A) => HKT<M, B>, b: B, fa: HKT<F, A>) => HKT<M, B>;
/**
 * Traverse a data structure, performing some effects encoded by an `Applicative` functor at each value, ignoring the final result.
 */
export declare function traverse_<M extends HKT3S, F>(M: Applicative<M>, F: Foldable<F>): <U, L, A, B>(f: (a: A) => HKT3As<M, U, L, B>, fa: HKT<F, A>) => HKT3As<M, U, L, void>;
export declare function traverse_<M extends HKT2S, F>(M: Applicative<M>, F: Foldable<F>): <L, A, B>(f: (a: A) => HKT2As<M, L, B>, fa: HKT<F, A>) => HKT2As<M, L, void>;
export declare function traverse_<M extends HKTS, F>(M: Applicative<M>, F: Foldable<F>): <A, B>(f: (a: A) => HKTAs<M, B>, fa: HKT<F, A>) => HKTAs<M, void>;
export declare function traverse_<M, F>(M: Applicative<M>, F: Foldable<F>): <A, B>(f: (a: A) => HKT<M, B>, fa: HKT<F, A>) => HKT<M, void>;
/**
 * Perform all of the effects in some data structure in the order given by the `Foldable` instance, ignoring the final result.
 */
export declare function sequence_<M extends HKT3S, F>(M: Applicative<M>, F: Foldable<F>): <U, L, A>(fa: HKT<F, HKT3As<M, U, L, A>>) => HKT3As<M, U, L, void>;
export declare function sequence_<M extends HKT2S, F>(M: Applicative<M>, F: Foldable<F>): <L, A>(fa: HKT<F, HKT2As<M, L, A>>) => HKT2As<M, L, void>;
export declare function sequence_<M extends HKTS, F>(M: Applicative<M>, F: Foldable<F>): <A>(fa: HKT<F, HKTAs<M, A>>) => HKTAs<M, void>;
export declare function sequence_<M, F>(M: Applicative<M>, F: Foldable<F>): <A>(fa: HKT<F, HKT<M, A>>) => HKT<M, void>;
/**
 * Combines a collection of elements using the `Alt` operation
 */
export declare function oneOf<F, P extends HKT3S>(F: Foldable<F>, P: Plus<P>): <U, L, A>(fga: HKT<F, HKT3As<P, U, L, A>>) => HKT3As<P, U, L, A>;
export declare function oneOf<F, P extends HKT2S>(F: Foldable<F>, P: Plus<P>): <L, A>(fga: HKT<F, HKT2As<P, L, A>>) => HKT2As<P, L, A>;
export declare function oneOf<F, P extends HKTS>(F: Foldable<F>, P: Plus<P>): <A>(fga: HKT<F, HKTAs<P, A>>) => HKTAs<P, A>;
export declare function oneOf<F, P>(F: Foldable<F>, P: Plus<P>): <A>(fga: HKT<F, HKT<P, A>>) => HKT<P, A>;
/**
 * Fold a data structure, accumulating values in some `Monoid`, combining adjacent elements using the specified separator
 * @function
 */
export declare const intercalate: <F, M>(F: Foldable<F>, M: Monoid<M>) => (sep: M) => (fm: HKT<F, M>) => M;
/**
 * Find the sum of the numeric values in a data structure
 * @function
 */
export declare const sum: <F, A>(F: Foldable<F>, S: Semiring<A>) => (fa: HKT<F, A>) => A;
/**
 * Find the product of the numeric values in a data structure
 * @function
 */
export declare const product: <F, A>(F: Foldable<F>, S: Semiring<A>) => (fa: HKT<F, A>) => A;
/**
 * Test whether a value is an element of a data structure
 * @function
 */
export declare const elem: <F, A>(F: Foldable<F>, S: Setoid<A>) => (a: A) => (fa: HKT<F, A>) => boolean;
/**
 * Try to find an element in a data structure which satisfies a predicate
 * @function
 */
export declare const find: <F>(F: Foldable<F>) => <A>(p: Predicate<A>) => (fa: HKT<F, A>) => Option<A>;
/**
 * Find the smallest element of a structure, according to its `Ord` instance
 * @function
 */
export declare const minimum: <F, A>(F: Foldable<F>, O: Ord<A>) => (fa: HKT<F, A>) => Option<A>;
/**
 * Find the largest element of a structure, according to its `Ord` instance
 * @function
 */
export declare const maximum: <F, A>(F: Foldable<F>, O: Ord<A>) => (fa: HKT<F, A>) => Option<A>;
/** @function */
export declare const toArray: <F>(F: Foldable<F>) => <A>(fa: HKT<F, A>) => A[];
