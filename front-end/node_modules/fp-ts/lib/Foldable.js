"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Monoid_1 = require("./Monoid");
var Apply_1 = require("./Apply");
var function_1 = require("./function");
var Ord_1 = require("./Ord");
var Option_1 = require("./Option");
/** @function */
exports.getFoldableComposition = function (F, G) {
    return {
        reduce: function (f, b, fga) { return F.reduce(function (b, ga) { return G.reduce(f, b, ga); }, b, fga); }
    };
};
/**
 * A default implementation of `foldMap` using `foldl`
 * @function
 */
exports.foldMap = function (F, M) { return function (f) { return function (fa) {
    return F.reduce(function (acc, x) { return M.concat(acc)(f(x)); }, M.empty(), fa);
}; }; };
/**
 * A default implementation of `foldr` using `foldMap`
 * @function
 */
exports.foldr = function (F) { return function (f) { return function (b) { return function (fa) {
    return exports.foldMap(F, Monoid_1.getEndomorphismMonoid())(f)(fa)(b);
}; }; }; };
/** @function */
exports.fold = function (F, M) { return function (fa) {
    return exports.foldMap(F, M)(function_1.identity)(fa);
}; };
/**
 * Similar to 'reduce', but the result is encapsulated in a monad.
 *
 * Note: this function is not generally stack-safe, e.g., for monads which
 * build up thunks a la `IO`.
 * @function
 */
function foldM(F, M) {
    return function (f, b, fa) { return F.reduce(function (mb, a) { return M.chain(function (b) { return f(b, a); }, mb); }, M.of(b), fa); };
}
exports.foldM = foldM;
/**
 * Traverse a data structure, performing some effects encoded by an `Applicative` functor at each value, ignoring the final result.
 * @function
 */
function traverse_(M, F) {
    return function (f, fa) { return exports.toArray(F)(fa).reduce(function (mu, a) { return Apply_1.applyFirst(M)(mu)(f(a)); }, M.of(undefined)); };
}
exports.traverse_ = traverse_;
/**
 * Perform all of the effects in some data structure in the order given by the `Foldable` instance, ignoring the final result.
 * @function
 */
function sequence_(M, F) {
    return function (fa) { return traverse_(M, F)(function (ma) { return ma; }, fa); };
}
exports.sequence_ = sequence_;
function oneOf(F, P) {
    return exports.foldr(F)(function (a) { return function (b) { return P.alt(a, b); }; })(P.zero());
}
exports.oneOf = oneOf;
/**
 * Fold a data structure, accumulating values in some `Monoid`, combining adjacent elements using the specified separator
 * @function
 */
exports.intercalate = function (F, M) { return function (sep) { return function (fm) {
    function go(_a, x) {
        var init = _a.init, acc = _a.acc;
        return init ? { init: false, acc: x } : { init: false, acc: M.concat(M.concat(acc)(sep))(x) };
    }
    return F.reduce(go, { init: true, acc: M.empty() }, fm).acc;
}; }; };
/**
 * Find the sum of the numeric values in a data structure
 * @function
 */
exports.sum = function (F, S) { return function (fa) {
    return F.reduce(function (b, a) { return S.add(b)(a); }, S.zero(), fa);
}; };
/**
 * Find the product of the numeric values in a data structure
 * @function
 */
exports.product = function (F, S) { return function (fa) {
    return F.reduce(function (b, a) { return S.mul(b)(a); }, S.one(), fa);
}; };
/**
 * Test whether a value is an element of a data structure
 * @function
 */
exports.elem = function (F, S) { return function (a) { return function (fa) {
    return F.reduce(function (b, x) { return b || S.equals(x)(a); }, false, fa);
}; }; };
/**
 * Try to find an element in a data structure which satisfies a predicate
 * @function
 */
exports.find = function (F) { return function (p) { return function (fa) {
    return F.reduce(function (b, a) {
        if (b.isNone() && p(a)) {
            return Option_1.some(a);
        }
        else {
            return b;
        }
    }, Option_1.none, fa);
}; }; };
/**
 * Find the smallest element of a structure, according to its `Ord` instance
 * @function
 */
exports.minimum = function (F, O) { return function (fa) {
    var min_ = Ord_1.min(O);
    return F.reduce(function (b, a) { return b.fold(function () { return Option_1.some(a); }, function (b) { return Option_1.some(min_(b)(a)); }); }, Option_1.none, fa);
}; };
/**
 * Find the largest element of a structure, according to its `Ord` instance
 * @function
 */
exports.maximum = function (F, O) { return function (fa) {
    var max_ = Ord_1.max(O);
    return F.reduce(function (b, a) { return b.fold(function () { return Option_1.some(a); }, function (b) { return Option_1.some(max_(b)(a)); }); }, Option_1.none, fa);
}; };
/** @function */
exports.toArray = function (F) { return function (fa) {
    return exports.foldMap(F, Monoid_1.monoidArray)(function (a) { return [a]; })(fa);
}; };
//# sourceMappingURL=Foldable.js.map